
# The Rizz Compiler

The **Rizz Compiler** is a compiler and interpreter pipeline written in **Haskell**.
It is divided into two main components:

* **The Compiler**, which transforms source code into bytecode
* **The Interpreter**, which executes the generated bytecode

---

## Compilation Pipeline

The compilation process of the **Rizz Compiler** is composed of **three distinct stages**:

1. **Lexing**
2. **Parsing**
3. **Transpiling**

Each stage progressively transforms the source code into a lower-level representation that can later be executed by the interpreter.

---

## The Rizz Compiler

### 1. Lexing

Lexing is the first and most straightforward stage of the compilation process.
Its role is to translate the raw source code into a stream of **tokens** that follow the compiler’s internal token system.

At this stage:

* Comments are removed
* Keywords, identifiers, literals, and symbols are converted into tokens
* Minimal error handling is performed, as lexing is mostly a mechanical translation step

The output of this phase is a list of tokens that will be consumed by the parser.

---

### 2. Parsing

Parsing operates at a higher level than lexing.
Here, tokens are grouped and structured into **compiler-understandable statements**, forming an **Abstract Syntax Tree (AST)**.

This stage includes significantly more error handling, such as:

* Verifying that the program follows the defined **BNF grammar**
* Detecting syntax errors
* Catching semantic issues like calls to undeclared variables

The resulting AST represents the logical structure of the program and serves as the foundation for further compilation.

---

### 3. Transpiling

Transpiling is the final stage of the compiler.
In this phase, the previously generated **AST** is transformed into the compiler’s **bytecode** representation.

This bytecode is a simplified, low-level format designed to be efficiently executed by the Rizz Interpreter.

---

## The Rizz Interpreter

The **Rizz-Compiled Interpreter** is responsible for executing the bytecode produced by the compiler.
It consists of **two main stages**:

1. **Parsing**
2. **Interpreting**

---

### 1. Bytecode Parsing

Parsing bytecode is significantly simpler than parsing tokens.
Since the bytecode has already been filtered and validated during compilation, it is less descriptive and more rigid than an AST.

At this stage, the interpreter:

* Reads and structures bytecode instructions
* Verifies runtime-related errors such as:

  * Accessing undeclared variables
  * Passing incorrect arguments to functions

---

### 2. Interpreting

Interpreting is the final execution step.
The interpreter walks through the bytecode instructions and evaluates them sequentially.

This includes:

* Performing arithmetic operations
* Executing function calls
* Managing runtime state and control flow

Once this step completes, the program has been fully executed.

---
