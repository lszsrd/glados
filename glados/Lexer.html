<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head id="head" data-base-url=".."><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Lexer</title><link href="../linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="../quick-jump.css" /><script src="../haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">glados-2.0.0: Generic Language And Data Operand Syntax</span><ul class="links" id="page-menu"><li><a href="src/Lexer.html">Source</a></li><li><a href="../index.html">Contents</a></li><li><a href="../doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>License</th><td>MIT</td></tr><tr><th>Maintainer</th><td>laszlo.serdet@epitech.eu</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Lexer</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Lexical analysis</a></li><li><a href="#g:2">Tokens parsing</a></li><li><a href="#g:3">Lexemes parsing</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Takes a stream of bytes and performs some checkups, based on a BNF grammar, to extract every <strong><code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code></strong> from it.</p><p>If an unexpected character is found or a multi line comment block is not closed, the <code><code><a href="Lexer.html#v:lexer" title="Lexer">lexer</a></code></code> function returns an error message using <code><code><a href="Format.html#v:fError" title="Format">fError</a></code></code> function.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:lexer">lexer</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Either String [(<a href="Tokens.html#t:Token" title="Tokens">Token</a>, (Int, Int))]</li><li class="src short"><a href="#v:lexerWrapper">lexerWrapper</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; (Int, Int) -&gt; Either String [(<a href="Tokens.html#t:Token" title="Tokens">Token</a>, (Int, Int))]</li><li class="src short"><a href="#v:parseBooleanConstant">parseBooleanConstant</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Token" title="Tokens">Token</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>)</li><li class="src short"><a href="#v:parseKeyword">parseKeyword</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Token" title="Tokens">Token</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>)</li><li class="src short"><a href="#v:hParseKeyword">hParseKeyword</a> :: (<a href="Tokens.html#t:Token" title="Tokens">Token</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) -&gt; Maybe (<a href="Tokens.html#t:Token" title="Tokens">Token</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>)</li><li class="src short"><a href="#v:parseLiteral">parseLiteral</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Token" title="Tokens">Token</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>)</li><li class="src short"><a href="#v:parsePunctuator">parsePunctuator</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Token" title="Tokens">Token</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>)</li><li class="src short"><a href="#v:parseMultiLineComment">parseMultiLineComment</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; (Int, Int) -&gt; (Int, Int) -&gt; Either String (<a href="Tokens.html#t:Stream" title="Tokens">Stream</a>, (Int, Int))</li><li class="src short"><a href="#v:parseStringLiteral">parseStringLiteral</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>)</li><li class="src short"><a href="#v:parseSCharSequence">parseSCharSequence</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>)</li><li class="src short"><a href="#v:parseSChar">parseSChar</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (Char, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>)</li><li class="src short"><a href="#v:parseDecimalConstant">parseDecimalConstant</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>)</li><li class="src short"><a href="#v:parseFloatingConstant">parseFloatingConstant</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>)</li><li class="src short"><a href="#v:parseDigitSequence">parseDigitSequence</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>)</li><li class="src short"><a href="#v:hParseDigitSequence">hParseDigitSequence</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>)</li><li class="src short"><a href="#v:parseCharacterConstant">parseCharacterConstant</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (Char, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>)</li><li class="src short"><a href="#v:parseChar">parseChar</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (Char, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>)</li><li class="src short"><a href="#v:parseEscapeSequence">parseEscapeSequence</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (Char, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>)</li><li class="src short"><a href="#v:parseIdentifier">parseIdentifier</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Identifier" title="Tokens">Identifier</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>)</li><li class="src short"><a href="#v:parseNonDigit">parseNonDigit</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (Char, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>)</li><li class="src short"><a href="#v:parseDigit">parseDigit</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (Char, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Lexical analysis</h1></a><div class="top"><p class="src"><a id="v:lexer" class="def">lexer</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Either String [(<a href="Tokens.html#t:Token" title="Tokens">Token</a>, (Int, Int))] <a href="src/Lexer.html#lexer" class="link">Source</a> <a href="#v:lexer" class="selflink">#</a></p><div class="doc"><p>Takes a <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> as parameter and returns a <strong>Either</strong> <code><code>String</code></code> [(<code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>, (<code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>))].</p><p>On success, this function returns a list of (<code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>) in which each token has a tuple of integers representing the token's line and column position.</p><p>On failure, this function returns a pretty formatted error message.</p></div></div><div class="top"><p class="src"><a id="v:lexerWrapper" class="def">lexerWrapper</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; (Int, Int) -&gt; Either String [(<a href="Tokens.html#t:Token" title="Tokens">Token</a>, (Int, Int))] <a href="src/Lexer.html#lexerWrapper" class="link">Source</a> <a href="#v:lexerWrapper" class="selflink">#</a></p><div class="doc"><p>Takes a <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> and a (<code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>) as parameters and returns a <strong>Either</strong> <code><code>String</code></code> [(<code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>, (<code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>))].</p><p>Note that the input <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code> tuple represents the stream's location starting index for both line and column.</p><p>On success, this function returns a list of (<code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>) in which each token has a tuple of integers representing the token's line and column position.</p><p>On failure, this function returns a pretty formatted error message.</p></div></div><a href="#g:2" id="g:2"><h1>Tokens parsing</h1></a><div class="top"><p class="src"><a id="v:parseBooleanConstant" class="def">parseBooleanConstant</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Token" title="Tokens">Token</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) <a href="src/Lexer.html#parseBooleanConstant" class="link">Source</a> <a href="#v:parseBooleanConstant" class="selflink">#</a></p><div class="doc"><p>Takes a <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> as parameter and returns a <strong>Maybe</strong> (<code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>) if the stream starts with a <code><code><a href="Tokens.html#v:BoolLiteral" title="Tokens">BoolLiteral</a></code></code>.</p><p>On success, this function returns a tuple made of the parsed <code><code><a href="Tokens.html#v:BoolLiteral" title="Tokens">BoolLiteral</a></code></code>, the <code><code><a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a></code></code> length and the input stream stripped of the parsed <code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>.</p></div></div><div class="top"><p class="src"><a id="v:parseKeyword" class="def">parseKeyword</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Token" title="Tokens">Token</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) <a href="src/Lexer.html#parseKeyword" class="link">Source</a> <a href="#v:parseKeyword" class="selflink">#</a></p><div class="doc"><p>Takes a <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> as parameter and returns a <strong>Maybe</strong> (<code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>) if the stream starts with a <code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>.</p><p>On success, this function returns a tuple made of the parsed <code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>, the <code><code><a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a></code></code> length and the input stream stripped of the parsed <code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>.</p></div></div><div class="top"><p class="src"><a id="v:hParseKeyword" class="def">hParseKeyword</a> :: (<a href="Tokens.html#t:Token" title="Tokens">Token</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) -&gt; Maybe (<a href="Tokens.html#t:Token" title="Tokens">Token</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) <a href="src/Lexer.html#hParseKeyword" class="link">Source</a> <a href="#v:hParseKeyword" class="selflink">#</a></p><div class="doc"><p>Takes a (<code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>) as parameter and returns a <strong>Maybe</strong> (<code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>) if the cut stream starts with a space character.</p><p><code><code><a href="Lexer.html#v:parseKeyword" title="Lexer">parseKeyword</a></code></code>'s helper function that checks if the very next character after the token is a space (to properly create a <code><code><a href="Token.html#v:Keyword" title="Token">Keyword</a></code></code> and not an <code><code><a href="Tokens.html#t:Identifier" title="Tokens">Identifier</a></code></code>) or a <code><code><a href="Tokens.html#v:Colon" title="Tokens">Colon</a></code></code> in case of function's parameter type.</p></div></div><div class="top"><p class="src"><a id="v:parseLiteral" class="def">parseLiteral</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Token" title="Tokens">Token</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) <a href="src/Lexer.html#parseLiteral" class="link">Source</a> <a href="#v:parseLiteral" class="selflink">#</a></p><div class="doc"><p>Takes a <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> as parameter and returns a <strong>Maybe</strong> (<code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>) if the stream starts with a <code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>.</p><p>On success, this function returns a tuple made of the parsed <code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>, the <code><code><a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a></code></code> length and the input stream stripped of the parsed <code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>.</p></div></div><div class="top"><p class="src"><a id="v:parsePunctuator" class="def">parsePunctuator</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Token" title="Tokens">Token</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) <a href="src/Lexer.html#parsePunctuator" class="link">Source</a> <a href="#v:parsePunctuator" class="selflink">#</a></p><div class="doc"><p>Takes a <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> as parameter and returns a <strong>Maybe</strong> (<code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>) if the stream starts with a <code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>.</p><p>On success, this function returns a tuple made of the parsed <code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>, the <code><code><a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a></code></code> length and the input stream stripped of the parsed <code><code><a href="Tokens.html#t:Token" title="Tokens">Token</a></code></code>.</p></div></div><a href="#g:3" id="g:3"><h1>Lexemes parsing</h1></a><div class="top"><p class="src"><a id="v:parseMultiLineComment" class="def">parseMultiLineComment</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; (Int, Int) -&gt; (Int, Int) -&gt; Either String (<a href="Tokens.html#t:Stream" title="Tokens">Stream</a>, (Int, Int)) <a href="src/Lexer.html#parseMultiLineComment" class="link">Source</a> <a href="#v:parseMultiLineComment" class="selflink">#</a></p><div class="doc"><p>Takes a 2 <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> (stream's start and stream's current position) and 2 (<code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>) (starting position and current position) as parameters and returns a <strong>Either</strong> <code><code>String</code></code> (<code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>, (<code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>)).</p><p>On success, this function returns a tuple made of the parsed comment block, enclosed in <code>`\*`</code> and <code>`*/`</code> and the new <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>'s current position. On failure, this function returns a pretty formatted error message.</p></div></div><div class="top"><p class="src"><a id="v:parseStringLiteral" class="def">parseStringLiteral</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) <a href="src/Lexer.html#parseStringLiteral" class="link">Source</a> <a href="#v:parseStringLiteral" class="selflink">#</a></p><div class="doc"><p>Takes a <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> as parameter and returns a <strong>Maybe</strong> (<code><code><a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a></code></code>, <code><code>Int</code></code>, <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>) if the stream starts with a &lt;string-literal&gt;.</p><p>This function is a wrapper around <code><code><a href="Lexer.html#v:parseSCharSequence" title="Lexer">parseSCharSequence</a></code></code> that checks whether the string literal starts and ends with the <code>`&quot;`</code> character.
 As such, it returns the same components and increases the total length by 2, taking into account both <code>`&quot;`</code> characters.</p></div></div><div class="top"><p class="src"><a id="v:parseSCharSequence" class="def">parseSCharSequence</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) <a href="src/Lexer.html#parseSCharSequence" class="link">Source</a> <a href="#v:parseSCharSequence" class="selflink">#</a></p><div class="doc"><p>Takes a <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> as parameter and returns a <strong>Maybe</strong> (<code><code><a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>) if the stream starts with a &lt;s-char-sequence&gt;.</p><p>On success, this function returns a tuple made of the parsed string literal, the string length and the input stream stripped of the parsed string literal.</p><p>This function differs from <code><code><a href="Lexer.html#v:parseCharacterConstant" title="Lexer">parseCharacterConstant</a></code></code> in that it accepts one or many characters and is surrounded by <code>`&quot;`</code> characters.</p></div></div><div class="top"><p class="src"><a id="v:parseSChar" class="def">parseSChar</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (Char, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) <a href="src/Lexer.html#parseSChar" class="link">Source</a> <a href="#v:parseSChar" class="selflink">#</a></p><div class="doc"><p>Takes a <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> as parameter and returns a <strong>Maybe</strong> (<code><code><a href="Data.html#v:Char" title="Data">Char</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>) if the stream starts with a &lt;s-char&gt;.</p><p>On success, this function returns a tuple made of the parsed character, the character length (which is always 1) and the input stream stripped of the parsed character.</p><p>This function differs from <code><code><a href="Lexer.html#v:parseChar" title="Lexer">parseChar</a></code></code> as it fails if the character <code>`&quot;`</code> is not escaped.</p></div></div><div class="top"><p class="src"><a id="v:parseDecimalConstant" class="def">parseDecimalConstant</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) <a href="src/Lexer.html#parseDecimalConstant" class="link">Source</a> <a href="#v:parseDecimalConstant" class="selflink">#</a></p><div class="doc"><p>Takes a <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> as parameter and returns a <strong>Maybe</strong> (<code><code><a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>) if the stream starts with a &lt;decimal-constant&gt;.</p><p>On success, this function returns a tuple made of the decimal string representation, the parsed integer length and the input stream stripped of the parsed integer.</p></div></div><div class="top"><p class="src"><a id="v:parseFloatingConstant" class="def">parseFloatingConstant</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) <a href="src/Lexer.html#parseFloatingConstant" class="link">Source</a> <a href="#v:parseFloatingConstant" class="selflink">#</a></p><div class="doc"><p>Takes a <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> as parameter and returns a <strong>Maybe</strong> (<code><code><a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>) if the stream starts with a &lt;floating-constant&gt;.</p><p>On success, this function returns a tuple made of the float string representation, the parsed float length (including the dot separator) and the input stream stripped of the parsed float.</p></div></div><div class="top"><p class="src"><a id="v:parseDigitSequence" class="def">parseDigitSequence</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) <a href="src/Lexer.html#parseDigitSequence" class="link">Source</a> <a href="#v:parseDigitSequence" class="selflink">#</a></p><div class="doc"><p>Takes a <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> as parameter and returns a <strong>Maybe</strong> (<code><code><a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>) if the stream starts with a &lt;digit-sequence&gt;.</p><p>On success, this function returns a tuple made of the digit string representation, the parsed digit length and the input stream stripped of the parsed digit.</p></div></div><div class="top"><p class="src"><a id="v:hParseDigitSequence" class="def">hParseDigitSequence</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) <a href="src/Lexer.html#hParseDigitSequence" class="link">Source</a> <a href="#v:hParseDigitSequence" class="selflink">#</a></p><div class="doc"><p>Takes a <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> as parameter and returns a <strong>Maybe</strong> (<code><code><a href="Tokens.html#t:Lexeme" title="Tokens">Lexeme</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>) if the stream starts with a &lt;digit-sequence&gt;.</p><p><code><code><a href="Lexer.html#v:parseDigitSequence" title="Lexer">parseDigitSequence</a></code></code>'s helper function that if the current stream a a digit sequence.</p></div></div><div class="top"><p class="src"><a id="v:parseCharacterConstant" class="def">parseCharacterConstant</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (Char, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) <a href="src/Lexer.html#parseCharacterConstant" class="link">Source</a> <a href="#v:parseCharacterConstant" class="selflink">#</a></p><div class="doc"><p>Takes a <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> as parameter and returns a <strong>Maybe</strong> (<code><code><a href="Data.html#v:Char" title="Data">Char</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>) if the stream starts with a &lt;character-constant&gt;.</p><p>On success, this function returns a tuple made of the parsed string literal, the string length and the input stream stripped of the parsed string literal.</p><p>This function differs from <code><code><a href="Lexer.html#v:parseSCharSequence" title="Lexer">parseSCharSequence</a></code></code> in that it accepts only one character and is surrounded by <code>`'`</code> characters.</p></div></div><div class="top"><p class="src"><a id="v:parseChar" class="def">parseChar</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (Char, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) <a href="src/Lexer.html#parseChar" class="link">Source</a> <a href="#v:parseChar" class="selflink">#</a></p><div class="doc"><p>Takes a <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> as parameter and returns a <strong>Maybe</strong> (<code><code><a href="Data.html#v:Char" title="Data">Char</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>) if the stream starts with a &lt;s-char&gt;.</p><p>On success, this function returns a tuple made of the parsed character, the character length (which is always 1) and the input stream stripped of the parsed character.</p><p>This function differs from <code><code><a href="Lexer.html#v:parseSChar" title="Lexer">parseSChar</a></code></code> as it fails if the character <code>`'`</code> is not escaped.</p></div></div><div class="top"><p class="src"><a id="v:parseEscapeSequence" class="def">parseEscapeSequence</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (Char, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) <a href="src/Lexer.html#parseEscapeSequence" class="link">Source</a> <a href="#v:parseEscapeSequence" class="selflink">#</a></p><div class="doc"><p>Takes a <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> as parameter and returns a <strong>Maybe</strong> (<code><code><a href="Data.html#v:Char" title="Data">Char</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>) if the stream starts with a &lt;escape-sequence&gt;.</p><p>On success, this function returns a tuple made of the parsed character, the character length (which is always 1) and the input stream stripped of the parsed character.</p></div></div><div class="top"><p class="src"><a id="v:parseIdentifier" class="def">parseIdentifier</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (<a href="Tokens.html#t:Identifier" title="Tokens">Identifier</a>, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) <a href="src/Lexer.html#parseIdentifier" class="link">Source</a> <a href="#v:parseIdentifier" class="selflink">#</a></p><div class="doc"><p>Takes a <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> as parameter and returns a <strong>Maybe</strong> (<code><code><a href="Data.html#v:Char" title="Data">Char</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>) if the stream starts with a &lt;identifier&gt;.</p><p>On success, this function returns a tuple made of the parsed identifier, the identifier length and the input stream stripped of the identifier.</p></div></div><div class="top"><p class="src"><a id="v:parseNonDigit" class="def">parseNonDigit</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (Char, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) <a href="src/Lexer.html#parseNonDigit" class="link">Source</a> <a href="#v:parseNonDigit" class="selflink">#</a></p><div class="doc"><p>Takes a <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> as parameter and returns a <strong>Maybe</strong> (<code><code><a href="Data.html#v:Char" title="Data">Char</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>) if the stream starts with a &lt;nondigit&gt;.</p><p>On success, this function returns a tuple made of the parsed character, the character length (which is always 1) and the input stream stripped of the parsed character.</p></div></div><div class="top"><p class="src"><a id="v:parseDigit" class="def">parseDigit</a> :: <a href="Tokens.html#t:Stream" title="Tokens">Stream</a> -&gt; Maybe (Char, Int, <a href="Tokens.html#t:Stream" title="Tokens">Stream</a>) <a href="src/Lexer.html#parseDigit" class="link">Source</a> <a href="#v:parseDigit" class="selflink">#</a></p><div class="doc"><p>Takes a <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code> as parameter and returns a <strong>Maybe</strong> (<code><code><a href="Data.html#v:Char" title="Data">Char</a></code></code>, <code><code><a href="Data.html#v:Int" title="Data">Int</a></code></code>, <code><code><a href="Tokens.html#t:Stream" title="Tokens">Stream</a></code></code>) if the stream starts with a &lt;digit&gt;.</p><p>On success, this function returns a tuple made of the parsed digit (as a <code><code><a href="Data.html#v:Char" title="Data">Char</a></code></code>), the digit length (which is always 1) and the input stream stripped of the parsed digit.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.27.0</p></div></body></html>